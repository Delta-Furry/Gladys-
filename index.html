<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>PIRATAS VR</title>
<link rel="icon" type="image/jpg" href="icongame.jpg"/>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #85929E;
    color: white;
    font-family: Arial, sans-serif;
  }
  #boton {
    background-color: white;
    color: black;
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-size: 40px;
    cursor: pointer;
    z-index: 10;
  }
  #boton p {
    font-size: 20px;
    margin-top: 10px;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>
<body>

<div id="boton">
  Da clic en + para iniciar VR
  <p>Recorrido en el mar ! DISFRUTA</p>
  <p>(  ) pulsa Esc para salir</p>
</div>

<canvas id="myCanvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "./js/three.module.js",
    "three/VRButton": "./js/VRButton.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/VRButton';

  import ESC01 from "./js/Brenda_PREP.js";
  import ESC02 from "./js/Crist_PREP.js";
  import ESC03 from "./js/Mauricio_PREP.js";
  import ESC04 from "./js/Lyn_PREP.js";

  const canvas = document.getElementById('myCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x85929E);
  renderer.xr.enabled = true;
  renderer.xr.setReferenceSpaceType('local');
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 4, 40);

  const light1 = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(light1);

  scene.add(ESC01({x:0, y:0, z:0}));
  scene.add(ESC02({x:0, y:10, z:-200}));
  scene.add(ESC03({x:-200, y:10, z:-200}));
  scene.add(ESC04({x:-200, y:10, z:0}));

  // --- NUEVO: Cubos teleportadores rojos ---
  const teleportTargets = [
    { position: new THREE.Vector3(0, 4, 40), coords: { x: 0, y: 4, z: 40 } },      
    { position: new THREE.Vector3(0, 4, -200), coords: { x: 0, y: 4, z: -200 } },  
    { position: new THREE.Vector3(-200, 4, -200), coords: { x: -200, y: 4, z: -200 } }, 
    { position: new THREE.Vector3(-200, 4, 0), coords: { x: -200, y: 4, z: 0 } }   
  ];

  teleportTargets.forEach(target => {
    const geo = new THREE.BoxGeometry(5, 5, 5);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(geo, mat);
    cube.position.copy(target.position);
    cube.userData.teleportTo = target.coords;
    scene.add(cube);
  });

  // Raycaster para detectar la vista
  const raycaster = new THREE.Raycaster();
  const tempMatrix = new THREE.Matrix4();
  let lookingAt = null;
  let lookingStartTime = 0;

  // Cruz central (retícula)
  const materialx = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
  const cross1 = new THREE.Mesh(new THREE.BoxGeometry(0.0075, 0.05, 0.075), materialx);
  const cross2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.0075, 0.075), materialx);
  camera.add(cross1, cross2);
  scene.add(camera);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  const boton = document.getElementById('boton');
  boton.addEventListener('click', () => {
    boton.style.display = 'none';
  });

  // --- LOOP PRINCIPAL ---
  function render() {
    // Raycaster dirección desde cámara
    tempMatrix.identity().extractRotation(camera.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(camera.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
      const obj = intersects[0].object;
      if (obj.userData.teleportTo) {
        if (lookingAt !== obj) {
          lookingAt = obj;
          lookingStartTime = performance.now();
        } else {
          const now = performance.now();
          if (now - lookingStartTime > 2000) { // 2 segundos mirando
            camera.position.set(
              obj.userData.teleportTo.x,
              obj.userData.teleportTo.y,
              obj.userData.teleportTo.z
            );
            lookingAt = null; // prevenir loops
          }
        }
      }
    } else {
      lookingAt = null;
    }

    renderer.render(scene, camera);
  }

  renderer.setAnimationLoop(render);
</script>

</body>
</html>
