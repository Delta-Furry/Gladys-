<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PIRATAS VR</title>
  <link rel="icon" type="image/jpg" href="icongame.jpg"/>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #85929E;
      color: white;
      font-family: Arial, sans-serif;
    }
    #boton {
      background-color: white;
      color: black;
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: 40px;
      cursor: pointer;
      z-index: 10;
    }
    #boton p {
      font-size: 20px;
      margin-top: 10px;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>

<div id="boton">
  Da clic en + para iniciar VR
  <p>Recorrido en el mar ! DISFRUTA</p>
  <p>(  ) pulsa Esc para salir</p>
</div>

<canvas id="myCanvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "./js/three.module.js",
    "three/VRButton": "./js/VRButton.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/VRButton';

  import ESC01 from "./js/Brenda_PREP.js";
  import ESC02 from "./js/Crist_PREP.js";
  import ESC03 from "./js/Mauricio_PREP.js";
  import ESC04 from "./js/Lyn_PREP.js";

  const canvas = document.getElementById('myCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x85929E);
  renderer.xr.enabled = true;
  renderer.xr.setReferenceSpaceType('local');
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 4, 40);

  const light1 = new THREE.AmbientLight(0xffffff, 1);
  scene.add(light1);

  // Escenarios
  scene.add(ESC01({x:0, y:0, z:0}));
  scene.add(ESC02({x:0, y:10, z:-200}));
  scene.add(ESC03({x:-200, y:10, z:-200}));
  scene.add(ESC04({x:-200, y:10, z:0}));

  // Cruceta (retícula)
  const crossColor = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const line1 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.05, 0.01), crossColor);
  const line2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.005, 0.01), crossColor);
  line1.position.z = -1;
  line2.position.z = -1;
  camera.add(line1, line2);
  scene.add(camera);

  // Teleport Cubos
  const teleportTargets = [
    { pos: new THREE.Vector3(0, 4, -10), target: new THREE.Vector3(-100, 4, -100) },
    { pos: new THREE.Vector3(-100, 4, -100), target: new THREE.Vector3(0, 4, 40) }
  ];

  const teleportCubes = [];

  teleportTargets.forEach(({ pos, target }) => {
    const geo = new THREE.BoxGeometry(5, 5, 5);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(geo, mat);
    cube.position.copy(pos);
    cube.userData.target = target;

    // Añadir anillo flotante decorativo
    const ringGeo = new THREE.TorusGeometry(3, 0.2, 8, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = 3;
    cube.add(ring);

    scene.add(cube);
    teleportCubes.push(cube);
  });

  // Raycaster
  const raycaster = new THREE.Raycaster();
  const tempMatrix = new THREE.Matrix4();
  let lookingAt = null;
  let lookStartTime = 0;

  // Click manual para VR o navegador normal
  window.addEventListener('click', () => {
    if (lookingAt && lookingAt.userData.target) {
      const destino = lookingAt.userData.target;
      camera.position.set(destino.x, destino.y, destino.z);
      lookingAt = null;
    }
  });

  // Botón de entrada
  document.getElementById('boton').addEventListener('click', () => {
    document.getElementById('boton').style.display = 'none';
  });

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Loop principal
  function animate() {
    // Ray desde la cámara hacia el frente
    tempMatrix.identity().extractRotation(camera.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(camera.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    const intersects = raycaster.intersectObjects(teleportCubes, true);

    if (intersects.length > 0) {
      const obj = intersects[0].object.parent || intersects[0].object;
      if (obj.userData.target) {
        if (lookingAt !== obj) {
          lookingAt = obj;
          lookStartTime = performance.now();
        } else {
          const now = performance.now();
          if (now - lookStartTime > 2000) {
            camera.position.copy(obj.userData.target);
            lookingAt = null;
          }
        }
      }
    } else {
      lookingAt = null;
    }

    renderer.render(scene, camera);
  }

  renderer.setAnimationLoop(animate);
</script>

</body>
</html>
