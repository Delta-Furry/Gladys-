<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PIRATAS VR</title>
  <link rel="icon" type="image/jpg" href="icongame.jpg"/>
  <style>
    body { margin: 0; overflow: hidden; background: #85929E; color: white; font-family: Arial, sans-serif; }
    #boton {
      background: white; color: black;
      position: absolute; width: 100%; height: 100%;
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      text-align: center; font-size: 40px;
      cursor: pointer; z-index: 10;
    }
    #boton p { font-size: 20px; margin-top: 10px; }
    canvas { display: block; width:100vw; height:100vh; }
  </style>
</head>
<body>

<div id="boton">
  Da clic en + para iniciar VR
  <p>Recorrido en el mar ¬°DISFRUTA!</p>
  <p>(  ) pulsa Esc para salir</p>
</div>
<canvas id="myCanvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three":             "./js/three.module.js",
    "three/VRButton":    "./js/VRButton.js",
    "tween":             "./js/tween.module.min.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/VRButton';
import { TWEEN } from 'tween';
import ESC01 from "./js/Brenda_PREP.js";
import ESC02 from "./js/Crist_PREP.js";
import ESC03 from "./js/Mauricio_PREP.js";
import ESC04 from "./js/Lyn_PREP.js";

// 1) Renderer + VRButton
const canvas   = document.getElementById('myCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// 2) Scene
const scene = new THREE.Scene();
scene.add(new THREE.AmbientLight(0xffffff, .5));

// 3) ‚ÄúPlayer‚Äù group que contendr√° la c√°mara
const player = new THREE.Group();
scene.add(player);

// 4) C√°mara dentro de player
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 4, 0);
player.add(camera);

// 5) A√±ade tus escenarios
scene.add( ESC01({ x:0,   y:0,  z:0    }) );
scene.add( ESC02({ x:0,   y:10, z:-200 }) );
scene.add( ESC03({ x:-200,y:10, z:-200 }) );
scene.add( ESC04({ x:-200,y:10, z:0    }) );

// 6) Crea cubos teleport (A = rojo, B = azul, C = naranja)
const cubes = [];
function makeCube(pos, color) {
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(4,4,4),
    new THREE.MeshLambertMaterial({ color, opacity:0.8, transparent:true })
  );
  m.position.set(pos.x, pos.y, pos.z);
  scene.add(m);
  cubes.push(m);
  return m;
}
const cubeA = makeCube({ x:0,   y:5, z:-5 }, 0xff0000);  // Rojo
const cubeB = makeCube({ x:30,  y:5, z:10 }, 0x0000ff);  // Azul
const cubeC = makeCube({ x:-30, y:5, z:15 }, 0xff8000);  // Naranja

// 7) Raycaster para mouse y controlador
const raycaster = new THREE.Raycaster();
const mouse     = new THREE.Vector2();
const tempMat   = new THREE.Matrix4();

// Teletransportaci√≥n
function teleportTo(position) {
  const from = { x: player.position.x, y: player.position.y, z: player.position.z };
  new TWEEN.Tween(from)
    .to({ x: position.x, y: position.y, z: position.z }, 800)
    .onUpdate(() => player.position.set(from.x, from.y, from.z))
    .start();
}

// 8) Click en modo normal
window.addEventListener('click', e => {
  mouse.x = (e.clientX/innerWidth)*2 -1;
  mouse.y = -(e.clientY/innerHeight)*2 +1;
  raycaster.setFromCamera(mouse, camera);
  const hit = raycaster.intersectObjects(cubes, false)[0];
  if (!hit) return;
  if (hit.object === cubeA) teleportTo(cubeB.position);
  else if (hit.object === cubeB) teleportTo(cubeC.position);
  else if (hit.object === cubeC) teleportTo(cubeA.position);
});

// 9) Controlador VR
const controller = renderer.xr.getController(0);
controller.addEventListener('select', () => {
  tempMat.identity().extractRotation(controller.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
  raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMat);
  const hit = raycaster.intersectObjects(cubes, false)[0];
  if (!hit) return;
  if (hit.object === cubeA) teleportTo(cubeB.position);
  else if (hit.object === cubeB) teleportTo(cubeC.position);
  else if (hit.object === cubeC) teleportTo(cubeA.position);
});
scene.add(controller);

// 10) Crosshair
const crossGeo = new THREE.BoxGeometry(0.0075,0.05,0.075);
const crossMat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
const c1 = new THREE.Mesh(crossGeo, crossMat);
const c2 = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.0075,0.075), crossMat);
c1.position.set(0,0,-1); c2.position.set(0,0,-1);
camera.add(c1, c2);

// 11) Bot√≥n de inicio
document.getElementById('boton').onclick = () => {
  document.getElementById('boton').style.display = 'none';
};

// 12) Resize
window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// 13) Render loop
function render() {
  TWEEN.update();
  renderer.render(scene, camera);
}
renderer.setAnimationLoop(render);

/* -----------------------------------------
   üöÄ Aqu√≠ puedes AGREGAR M√ÅS C√ìDIGOS despu√©s
   ----------------------------------------- */
</script>
</body>
</html>
